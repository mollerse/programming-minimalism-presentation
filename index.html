<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, maximum-scale=1, user-scalable=no"
    />
    <link
      href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII="
      rel="icon"
      type="image/x-icon"
    />
    <title>In praise of programming minimalism</title>

    <style>
      @import url("/node_modules/reveal.js/dist/reveal.css");
      @import url("/node_modules/reveal.js/dist/theme/night.css");
      /* Highlight.js styling */
      @import url("/src/darcula.css");

      * {
        box-sizing: border-box;
      }

      body {
        aspect-ratio: 16/9;
        width: 100vw !important;
        height: calc((9 / 16) * 100vw) !important;
      }
      /* Landscape */
      @media (min-aspect-ratio: 16/9) {
        body {
          height: 100vh !important;
          width: calc((16 / 9) * 100vh) !important;
        }
      }
      /* Reveal.js styles */
      :root {
        --background-color: #050505;
        --main-color: #ebebeb;
        --accent-color: hotpink;
        --main-font: "DejaVu Sans", Helvetica, sans-serif;
        --font-weight: 300;
        --font-size: calc(var(--scale, 1) * 3em);
        --r-main-font-size: var(--font-size);
        --r-background-color: var(--background-color);
        --r-main-font: var(--main-font);
        --r-main-color: var(--main-color);
        --r-heading-font: var(--main-font);
        --r-heading-color: var(--main-color);
        --r-heading-font-weight: var(--font-weight);
        --r-link-color: var(--accent-color);
        --r-link-color-hover: var(--accent-color);
        --r-heading-text-transform: uppercase;
      }

      /* CodeMirror styles */
      .cm-editor {
        width: calc(100% - 6px);
        height: calc(100% - 6px);
        left: 3px;
        top: 3px;
      }

      .cm-focused .cm-cursor {
        border-left-color: var(--accent-color);
        border-left-width: 2px;
      }

      .cm-focused {
        outline: 3px solid var(--r-main-color) !important;
      }

      p {
        font-weight: var(--font-weight);
      }

      .editor {
        --r-main-font-size: 24px;
        font-size: var(--r-main-font-size);
      }

      /* Other styles */
      .slides > section {
        height: 100%;
        width: 100%;
        padding: 2.5%;
      }

      .center {
        flex-direction: column;
        justify-content: center;
      }

      .center p {
        margin: 0;
        line-height: 1.5;
      }

      .center .small {
        font-size: 75%;
      }

      .standard {
        flex-direction: column;
        justify-content: left;
        text-align: left;
      }

      .standard h2 {
      }

      .standard > div {
        flex-grow: 1;
        padding: 2.5%;
        padding-top: 0;
      }

      .standard p {
        margin: 1em 0;
        max-width: 80%;
      }

      .standard sup {
        font-size: 50%;
      }

      .standard p.small {
        font-size: 50%;
      }
      .standard p.smaller {
        font-size: 35%;
      }

      .standard pre {
        width: 100% !important;
      }

      .standard p:has(+ pre) {
        position: absolute;
        font-family: var(--r-code-font);
        right: 5.5%;
        margin: 0;
        z-index: 1;
      }

      .standard p + pre {
        margin-top: 0;
      }

      .standard pre code {
        max-height: none;
      }

      .standard .no-margin-bottom {
        margin-bottom: 0 !important;
      }

      .no-spacing p {
        margin: 0;
      }

      ait-slide {
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: space-between;
      }

      ait-slide * {
        box-sizing: border-box;
      }

      .editor {
        width: 49%;
        height: 100%;
        text-align: left;
        overflow-y: scroll;
      }

      .display {
        width: 49%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .display canvas {
        border: 3px solid #ebebeb;
      }

      ul.stack {
        list-style: none;
        display: flex;
        flex-direction: column;
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        align-items: center;
        justify-content: flex-start;
      }

      .stack li {
        border: 3px solid #ebebeb;
        width: 100%;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <!-- Intro -->
        <section class="center">
          <h1>In praise of<br />programming<br />minimalism</h1>
          <p class="small">Stian Veum Møllersen / @mollerse</p>
          <p class="small">#HelloStavanger 2024</p>
        </section>
        <!-- Hei -->
        <section class="standard">
          <h2>Hei!</h2>
          <div>
            <p>Jeg heter Stian og jobber i Visuelle Historier i NRK.</p>
            <p class="fragment">
              Som vil si at jeg jobber med redaksjonelt innhold på web; langlesing, interaktivt
              innhold, datakverning etc.
            </p>
          </div>
        </section>
        <!-- Språk -->
        <section class="standard">
          <h2>Språk</h2>
          <div>
            <p>
              Jeg er veldig glad i språk. Både konstruerte, som de vi bruker til programmering, og
              naturlige språk.
            </p>
            <p class="fragment">
              Så det at jeg jobber med redaksjonelt innhold til web passer meg ganske bra.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Språk</h2>
          <div>
            <p>Som utviklere er vi omgitt av språk på alle kanter.</p>
            <p class="fragment">
              Noen ganger blir språket vi velger å uttrykke oss i når vi programmerer som vann for
              en gullfisk.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Språk</h2>
          <div>
            <p>
              Men det er mye spennende innsikt å hente ved å bruke litt tid til å reflektere over
              språket vi bruker.
            </p>
            <p class="fragment">Vil dere høre en funfact om honning?</p>
            <p class="fragment small">Klart dere vil, for dere har ikke noe valg.</p>
            <p class="fragment smaller">(Jeg burde strengt tatt kalt det en arti-fakta)</p>
          </div>
        </section>
        <section class="standard">
          <h2>Honning</h2>
          <div>
            <p>
              Nesten samtlige språk i Europa har et ord for honning som stammer fra ett av 2/3
              eldgamle ord: *médʰu/*mélit og *kn̥h₂ónks.
            </p>
            <p class="fragment">miel🇫🇷🇪🇸, mel 🇵🇹, miele🇮🇹, mil🏴󠁧󠁢󠁳󠁣󠁴󠁿🇮🇪, méli🇬🇷</p>
            <p class="fragment">med🇷🇸🇧🇦🇭🇷🇲🇪🇸🇮🇲🇰🇧🇬🇺🇦, miód🇵🇱, mjod🇷🇺, medus🇱🇻🇱🇹</p>
            <p class="fragment">honey🇬🇧, honning🇳🇴🇩🇰, honung🇸🇪, honing🇳🇱🇧🇪, honig🇩🇪</p>
          </div>
        </section>
        <section class="standard">
          <h2>Honning</h2>
          <div>
            <p>
              Dette er utrolig fascinerende. Hvorfor er ordene så like? Hvorfor bruker de germanske
              språkene en annen variant enn romance og slavisk?
            </p>
            <p class="fragment">
              Honning har vært en del av menneskehetens verden i veldig lang tid, så de trengte et
              ord for det veldig tidlig.
            </p>
            <p class="fragment">
              Men på et eller annet tidspunkt valgte noen å henvise til honning basert på farge og
              ikke smak.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Språk</h2>
          <div>
            <p>Språk reflekterer verdensbilde.</p>
            <p class="fragment">Dette gjelder óg i aller høyeste grad programmeringspråk.</p>
          </div>
        </section>
        <section class="standard">
          <h2>Språk</h2>
          <div>
            <p>
              På samme måte som vi grupperer de naturlige språkene i familier, grupperer vi
              programmeringspråk etter paradigme.
            </p>
            <p class="fragment">germansk/romance/slavisk ~ OO/funksjonell/prosedyre</p>
            <p class="fragment small">
              (vi kan tilogmed utvide metaforen til å inkludere Finno-Ugrisk og logisk
              programmering.)
            </p>
            <p class="fragment smaller">(Finsk og Prolog har litt samme vibes.)</p>
          </div>
        </section>
        <section class="standard">
          <h2>Abstraksjon og begreper</h2>
          <div>
            <p>Med en gang vi har et begrep for noe blir det enklere å snakke om og tenke på.</p>
            <p class="fragment">
              «Hygge» omfatter mange forskjellige følelser og sammenhenger. Naturlig for en
              Skandinav, mystisk for en Brite.
            </p>
          </div>
        </section>
        <section class="center">
          <blockquote>
            «A language that doesn't affect the way you think about programming is not worth
            knowing.»
          </blockquote>
          <p>&mdash;Alan Perlis</p>
        </section>
        <!-- Perlis-språk -->
        <section class="standard">
          <h2>Perlis-språk</h2>
          <div>
            <p>Svensk for en Norsktalende er litt som C# for en Java-utvikler.</p>
            <p class="fragment">
              Hvis målet er å få en ny verdensforståelse og nye begreper bør vi kanskje sikte litt
              lengre vekk.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Perlis-språk</h2>
          <div>
            <p>Det er alltid fristende å oppsøke det som <em>ser</em> mest annerledes ut.</p>
            <p class="fragment">
              Forskjell i syntaks betyr ikke nødvendigvis forskjell i semantikk.
            </p>
          </div>
        </section>
        <section class="center">
          <blockquote>
            «Beware of the Turing tar-pit in which everything is possible but nothing of interest is
            easy.»
          </blockquote>
          <p>&mdash;Alan Perlis</p>
        </section>
        <section class="standard">
          <h2>«The Turing Tar-pit»</h2>
          <div>
            <p>
              Det er fristende å oppsøke de snåleste programmeringspråkene med den mest
              ugjennomtrengelige syntaksen.
            </p>
            <p class="fragment">
              Under syntaxen er det ikke nødvendigvis så fryktelig mye spennende.
            </p>
            <p class="fragment">
              Når du først forstår hva en stack machine gjør er det ikke så spennende at syntaxen
              kun består av forskjellige whitespaces.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Perlis-språk</h2>
          <div>
            <p>Vi trenger en annen heurestikk for å finne et interessant språk.</p>
            <p class="fragment">
              Vi trenger programmeringsverdenens Baskisk, Europas eneste isolerte språk.
            </p>
            <p class="fragment">(Honning på Baskisk er forøvrig <em>ezti</em>.)</p>
          </div>
        </section>
        <section class="standard">
          <h2>Perlis-språk</h2>
          <div>
            <p>Vi trenger et språk med interessant semantikk.</p>
            <p class="fragment">
              Et språk med et annet verdensbilde enn de etablerte språkfamiliene.
            </p>
          </div>
        </section>
        <!-- Konkatenative språk -->
        <section class="center">
          <h3>Konkatenativ programmering</h3>
        </section>
        <section class="standard">
          <h2>Konkatenativ programmering</h2>
          <div>
            <p>
              En familie med språk hvor den primære operasjonen for å konstruere programmer er
              komposisjon gjennom jukstaposisjon.
            </p>
            <p class="fragment">
              Med andre ord: Vi setter funksjoner ved siden av hverandre i en sekvens og kaller det
              komposisjon.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Konkatenativ programmering</h2>
          <div>
            <p>For å illustrere med litt kode:</p>
            <p></p>
            <pre><code data-trim data-noescape class="language-js">
              f(g())
              // eller
              pipe(g, f)
              // eller
              g |> f
            </code></pre>
            <div class="fragment">
              <p>blir:</p>
              <p></p>
              <pre><code data-trim data-noescape>g f</code></pre>
            </div>
          </div>
        </section>
        <section>
          <ait-slide demo="triangles">
            <div class="editor"></div>
            <div class="display canvas"></div>
          </ait-slide>
        </section>
        <section class="standard">
          <h2>Komposisjon</h2>
          <div>
            <p>
              Hva er egentlig forskjellen på komposisjon gjennom jukstaposisjon og point-free
              komposisjon vi finner i mange andre språk?
            </p>
            <div class="fragment">
              <p></p>
              <pre><code data-trim data-noescape class="language-js">
                g |> f
                // eller
                g . f
              </code></pre>
            </div>
            <p class="fragment">
              Forskjellen åpenbarer seg når vi ser på komposisjon av funksjoner som har
              ikke-kompatible signaturer.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Komposisjon</h2>
          <div>
            <p>La oss si at vi har to funksjoner:</p>
            <p></p>
            <pre><code data-trim data-noescape data-line-numbers>
              fnA: (a: string) => string
              fnB: (a: string, b: string) => string
            </code></pre>
            <p class="fragment">
              <code>fnB</code> kan enkelt komponeres med <code>fnA</code>, men ikke omvendt.
            </p>
            <div class="fragment">
              <p></p>
              <pre><code data-trim data-noescape data-line-numbers>
                # (string, string) => string
                fn = fnB |> fnA
              </code></pre>
            </div>
            <div class="fragment">
              <p></p>
              <pre><code data-trim data-noescape data-line-numbers>
                # string => string
                fn = fnA |> (fnB "str")
              </code></pre>
            </div>
          </div>
        </section>
        <section class="standard">
          <h2>Komposisjon</h2>
          <div>
            <p>
              Hvordan skal du løse dette i et språk som kun tillater komposisjon gjennom
              jukstaposisjon?
            </p>
            <p class="fragment">Trikset er å gjøre alle funksjoner kompatible.</p>
            <div class="fragment">
              <p></p>
              <pre><code data-trim data-noescape data-line-numbers>
                // Hva er T? We don't know.
                fnA: (a: T) => T
                fnB: (a: T) => T

                fn = fnA |> fnB
              </code></pre>
            </div>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>
              Nå er utfordringen å finne en form på <code>T</code> som lar oss oppnå det samme som
              før.
            </p>
            <p class="fragment">
              <code>T</code> må være noe vi kan skrive og lese data fra, men som ikke har for mange
              ulemper ved seg.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>
              <code>T</code> kan være et stort tilstands-atom, eller register. Da må vi hele tiden
              vite hvilke nøkler eller regiser-navn vi bruker til hva.
            </p>
            <p class="fragment">
              Heldigvis finnes det en en godt egna datastruktur for akkurat dette formålet.
            </p>
            <p class="fragment">En stack!</p>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Det er dette som er «the secret sauce».</p>
            <p class="fragment">
              <em>Alt</em> er funksjoner som tar en stack og returnerer en stack.
            </p>
            <p class="fragment">
              Tall er funksjoner, stringer er funksjoner, operatorer er funksjoner, osv
            </p>
            <p class="fragment">Funksjonene leser og skriver til stack'en for å utføre oppgaver.</p>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Vi starter med litt JS:</p>
            <div class="fragment">
              <p class="small">&lt;js&gt;</p>
              <pre><code data-trim data-noescape data-line-numbers="1-10|1-3|5-7|8-8|10-10|1-10" class="language-js">
                function add(a, b) {
                  return a + b
                }

                let value = 0
                let step = 4
                let error = 1
                let addEstimate = a => add(5, a)

                (addEstimate(value) - error) % step === 0 // => true
              </code></pre>
            </div>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Vi skriver om litt, sånn at alt er funksjoner:</p>
            <p class="small">&lt;js&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-20|14-18|1-12|20-20|1-20" class="language-js">
              function add(a, b) {
                return a + b
              }
              function sub(a, b) {
                return a - b
              }
              function eq(a, b) {
                return a === b
              }
              function mod(a, b) {
                return a % b
              }

              let value = 0
              let findStep = a => mod(a, 4)
              let withoutError = a => sub(a, 1)
              let addEstimate = a => add(5, a)
              let isAcceptable = a => eq(0, a)

              isAcceptable(findStep(withoutError(addEstimate(value)))) // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Kan bruke (en tenkt) pipeline-funksjon:</p>
            <p class="small">&lt;js&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-20|20-20|1-20" class="language-js">
              function add(a, b) {
                return a + b
              }
              function sub(a, b) {
                return a - b
              }
              function eq(a, b) {
                return a === b
              }
              function mod(a, b) {
                return a % b
              }

              let value = 0
              let findStep = a => mod(a, 4)
              let withoutError = a => sub(a, 1)
              let addEstimate = a => add(5, a)
              let isAcceptable = a => eq(0, a)

              pipeline(addEstimate, withoutError, findStep, isAcceptable)(value) // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Eller en egen pipe-operator:</p>
            <p class="small">&lt;js?&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-21|20-21|1-21" class="language-js">
              function add(a, b) {
                return a + b
              }
              function sub(a, b) {
                return a - b
              }
              function eq(a, b) {
                return a === b
              }
              function mod(a, b) {
                return a % b
              }

              let value = 0
              let findStep = a => mod(a, 4)
              let withoutError = a => sub(a, 1)
              let addEstimate = a => add(5, a)
              let isAcceptable = a => eq(0, a)

              let program = addEstimate |> withoutError |> findStep |> isAcceptable
              program(value) // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Så var det denne <code>T</code>'en:</p>
            <div class="fragment">
              <p class="small">&lt;js?&gt;</p>
              <pre><code data-trim data-noescape data-line-numbers="1-5|1-3|2-2|1-3|5-5|1-5" class="language-js">
                function add(args) {
                  return args[0] + args[1]
                }
                // ...
                let addEstimate = a => add([5, a])
              </code></pre>
            </div>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Vi bruker en stack til lesing og skriving:</p>
            <p class="small">&lt;js?&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-9|1-7|2-3|5-5|6-6|1-7|9-9|1-9" class="language-js">
              function add(args) {
                let a = args.pop()
                let b = args.pop()

                let sum = a + b
                args.push(sum)
              }
              // ...
              let addEstimate = a => add([5, a])
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Vi bruker en stack til lesing og skriving:</p>
            <p class="small">&lt;js?&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-12|1-7|9-12|10-10|11-11|1-12" class="language-js">
              function add(args) {
                let a = args.pop()
                let b = args.pop()

                let sum = a + b
                args.push(sum)
              }
              // ...
              function addEstimate(args) {
                args.push(5)
                add(args)
              }
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Vi bruker en stack til lesing og skriving:</p>
            <p class="small">&lt;js?&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-14|1-1|3-3|11-11|1-14" class="language-js">
              const STACK = []

              function add() {
                let a = STACK.pop()
                let b = STACK.pop()

                let sum = a + b
                STACK.push(sum)
              }
              // ...
              function addEstimate() {
                STACK.push(5)
                add(STACK)
              }
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Skriver om koden til å bruke stack'en til alt:</p>
            <p class="small">&lt;js?&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-14|3-3|5-9|11-11|1-14" class="language-js">
              const STACK = []

              // add, mod, sub, eq

              function value() { STACK.push(0) }
              function findStep() { STACK.push(4); mod() }
              function withoutError() { STACK.push(1); sub() }
              function addEstimate() { STACK.push(5); add() }
              function isAcceptable() { STACK.push(0); eq() }

              let program = addEstimate |> withoutError |> findStep |> isAcceptable

              value()
              program() // => ???
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Skriver om koden til å bruke stack'en til alt:</p>
            <p class="small">&lt;??&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-14|5-9|1-14|13-14|6-7|1-14" class="language-js">
              const STACK = []

              // add, mod, sub, eq

              let value = STACK.push(0)
              let findStep = STACK.push(4) |> mod
              let withoutError = STACK.push(1) |> sub
              let addEstimate = STACK.push(5) |> add
              let isAcceptable = STACK.push(0) |> eq

              let program = addEstimate |> withoutError |> findStep |> isAcceptable

              value()
              program() // => ???
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Stack-operatorer:</p>
            <p class="small">&lt;??&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-21|5-10|13-14|12-16|20-21|1-21" class="language-js">
              const STACK = []

              // add, mod, sub, eq

              function swap() {
                let a = STACK.pop()
                let b = STACK.pop()
                STACK.push(a)
                STACK.push(b)
              }

              let value = STACK.push(0)
              let findStep = STACK.push(4) |> swap |> mod
              let withoutError = STACK.push(1) |> swap |> sub
              let addEstimate = STACK.push(5) |> add
              let isAcceptable = STACK.push(0) |> eq

              let program = addEstimate |> withoutError |> findStep |> isAcceptable

              value()
              program() // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Nå er faktisk alt funksjoner:</p>
            <div class="fragment">
              <p class="small">&lt;??&gt;</p>
              <pre><code data-trim data-noescape data-line-numbers="1-14" class="language-js">
                const STACK = []

                // add, mod, sub, eq, swap

                let value = STACK.push(0)
                let findStep = STACK.push(4) |> swap |> mod
                let withoutError = STACK.push(1) |> swap |> sub
                let addEstimate = STACK.push(5) |> add
                let isAcceptable = STACK.push(0) |> eq

                let program = addEstimate |> withoutError |> findStep |> isAcceptable

                value()
                program() // => true
              </code></pre>
            </div>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Stack'en blir en implementasjonsdetalj:</p>
            <p class="small">&lt;??&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-14|5-9|1-1|1-14" class="language-js">
              // STACK er en implementasjonsdetalj

              // add, mod, sub, eq, swap

              let value = 0
              let findStep = 4 |> swap |> mod
              let withoutError = 1 |> swap |> sub
              let addEstimate = 5 |> add
              let isAcceptable = 0 |> eq

              let program = addEstimate |> withoutError |> findStep |> isAcceptable

              value()
              program() // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Invokasjon er implisitt:</p>
            <p class="small">&lt;??&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-13|13-13|1-13" class="language-js">
              // STACK er en implementasjonsdetalj

              // add, mod, sub, eq, swap

              let value = 0
              let findStep = 4 |> swap |> mod
              let withoutError = 1 |> swap |> sub
              let addEstimate = 5 |> add
              let isAcceptable = 0 |> eq

              let program = addEstimate |> withoutError |> findStep |> isAcceptable

              value |> program // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Jukstaposisjon er komposisjon:</p>
            <p class="small">&lt;??&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-13" class="language-js">
              // STACK er en implementasjonsdetalj

              // add, mod, sub, eq, swap

              let value = 0
              let findStep = 4 swap mod
              let withoutError = 1 swap sub
              let addEstimate = 5 add
              let isAcceptable = 0 eq

              let program = addEstimate withoutError findStep isAcceptable

              value program // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Operatorer er funksjoner:</p>
            <p class="small">&lt;??&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-13" class="language-js">
              // STACK er en implementasjonsdetalj

              // add/+, mod/%, sub/-, eq/==, swap

              let value = 0
              let findStep = 4 swap %
              let withoutError = 1 swap -
              let addEstimate = 5 +
              let isAcceptable = 0 ==

              let program = addEstimate withoutError findStep isAcceptable

              value program // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>En liten syntaktisk transformasjon:</p>
            <p class="small">&lt;ait&gt;</p>
            <pre><code data-trim data-noescape data-line-numbers="1-13" class="language-js">
              // STACK er en implementasjonsdetalj

              // add/+, mod/%, sub/-, eq/==, swap

              value: 0 ;
              findStep: 4 swap % ;
              withoutError: 1 swap - ;
              addEstimate: 5 + ;
              isAcceptable: 0 = ;

              program: addEstimate withoutError findStep isAcceptable ;

              value program // => true
            </code></pre>
          </div>
        </section>
        <section class="standard">
          <h2>Alt er funksjoner</h2>
          <div>
            <p>Hvis vi formaterer koden litt annerledes...</p>
            <div class="fragment">
              <p class="small">&lt;ait&gt;</p>
              <pre><code data-trim data-noescape data-line-numbers="1-13" class="language-js">
                value: 0 ;
                findStep: 4 swap % ;
                withoutError: 1 swap - ;
                addEstimate: 5 + ;
                isAcceptable: 0 == ;

                value
                addEstimate
                withoutError
                findStep
                isAcceptable // => true
              </code></pre>
            </div>
            <p class="fragment">Fra JS til konkatenativ programmering på 5 minutter!</p>
          </div>
        </section>
        <section class="standard">
          <h2>Medaljens bakside</h2>
          <div>
            <p>
              Som dere allerede har fått litt smakebit av er det en ganske åpenbar bakside til denne
              befriende syntaksen.
            </p>
            <p class="fragment">Det er mye mikk med en stack.</p>
          </div>
        </section>
        <section>
          <ait-slide demo="arithmetics">
            <div class="editor"></div>
            <div class="display"></div>
          </ait-slide>
        </section>
        <!-- What of intrest is easy? -->
        <section class="center">
          <blockquote>
            «Beware of the Turing tar-pit in which everything is possible but nothing of interest is
            easy.»
          </blockquote>
          <p>&mdash;Alan Perlis</p>
        </section>
        <section class="standard">
          <h2>«...[What] of intrest is easy?»</h2>
          <div>
            <p>Det er jo det store spørsmålet her.</p>
            <p class="fragment">
              Konkatenative språk er åpenbart Turing-komplette, så alt er mulig.
            </p>
            <p class="fragment">Så hvilke interessante ting kan vi gjøre lett?</p>
          </div>
        </section>
        <section class="standard">
          <h2>«...[What] of intrest is easy?»</h2>
          <div>
            <p>
              Det kan være fristende å relegere konkatenative språk til «stack-based languages».
            </p>
            <p class="fragment">
              Men konkatenative språks «stackiness» er egentlig ikke det interessante her.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Delvis evaluering</h2>
          <div>
            <p>
              At programmer konstrueres med kun en type operasjon kan vi evaluere programmer
              stykkevis og delt.
            </p>
            <div class="fragment">
              <p>Alle disse formene er ekvivalente:</p>
              <p></p>
              <pre><code data-trim data-noescape data-line-numbers class="language-js">
                valueA valueB operationA operationB

                (valueA valueB) operationA operationB

                valueA valueB (operationA operationB)

                valueA (valueB operationA) operationB

                (valueA valueB operationA) operationB
              </code></pre>
            </div>
          </div>
        </section>
        <section class="standard">
          <h2>Delvis evaluering</h2>
          <div>
            <p>Dette har noen interessante følger for ting som parallelisering og strømming.</p>
            <p class="fragment">
              Alle subsett av programmet kan reduseres til et program som tar en stack og returnerer
              en stack.
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Delvis evaluering</h2>
          <div>
            <p>Å implementere en kompilator eller tolker blir en veldig enkel oppgave.</p>
            <p class="fragment">
              (Faktisk så enkel at jeg har implementert et enkelt konkatenativt språk som brukes til
              demoer i disse slidene.)
            </p>
          </div>
        </section>
        <section class="standard">
          <h2>Programmer som data</h2>
          <div>
            <p>Det er bare rekkefølgen som betyr noe ved evaluering.</p>
            <p class="fragment">
              Dermed kan du putte kode-som-data inn i programmet og markere det for eksekvering ved
              å modifisere strømmen av kode som sendes til evaluering.
            </p>
            <p class="fragment">Noe som igjen gjør høyere-ordens funksjoner mulig.</p>
          </div>
        </section>
        <section>
          <ait-slide demo="hof">
            <div class="editor"></div>
            <div class="display"></div>
          </ait-slide>
        </section>
        <section>
          <ait-slide demo="linrec">
            <div class="editor"></div>
            <div class="display"></div>
          </ait-slide>
        </section>
        <section class="standard">
          <h2>Tankenær kode</h2>
          <div>
            <p>Syntaksen og semantikken legger opp til kortfattethet.</p>
            <p class="fragment">
              Du ledes hele tiden mot å bearbeide koden til noe som fanger kompleksiteten bak et lag
              av mening.
            </p>
            <p class="fragment small">(Hvem sa at pisk ikke var effektivt.)</p>
          </div>
        </section>
        <section class="standard">
          <h2>Tankenær kode</h2>
          <div>
            <p>«Factoring» ble den prosessen kalt blandt FORTH-programmerere.</p>
            <div class="fragment no-spacing">
              <p>Factor</p>
              <p>...to clarify meaning</p>
              <p>...to give something a name</p>
              <p>...to avoid repitition</p>
              <p>...to hide details likely to change</p>
              <p>...to simplify APIs</p>
            </div>
            <p class="fragment small">
              (Dette er altså 10 år før «Refactoring» ble et vanlig begrep)
            </p>
          </div>
        </section>
        <section>
          <ait-slide demo="triangle-fun">
            <div class="editor"></div>
            <div class="display canvas"></div>
          </ait-slide>
        </section>
        <section>
          <ait-slide demo="triangle-fun-done">
            <div class="editor"></div>
            <div class="display canvas"></div>
          </ait-slide>
        </section>
        <section class="standard">
          <h2>Tankenær kode</h2>
          <div>
            <p>
              Det minimalistiske settet med valg du har til en hver tid tvinger deg til å tenke.
            </p>
            <p class="fragment">
              Og det gjør at du må angripe problemløsning med kode på en annen måte.
            </p>
            <p class="fragment small">
              (Og det er utrolig deilig å slippe fetisjiseringen av mengde kode som et mål på
              produktivitet.)
            </p>
          </div>
        </section>
        <section class="center">
          <h2>Nysgjerrig?</h2>
          <div class="fragment">
            <p><a href="https://concatenative.org">concatenative.org</a></p>
            <p><a href="https://thinking-forth.sourceforge.net/">Thinking FORTH</a></p>
            <p>
              <a href="https://leanpub.com/readevalprintlove003/read">Read-Eval-Print-λove #3</a>
            </p>
            <p><a href="https://factorcode.org/">Factor programming language</a></p>
          </div>
        </section>
        <section class="center">
          <p>Om ikke anna har dere lært hva jukstaposisjon er 😎</p>
        </section>
        <section class="center">
          <h2>Fin.</h2>
          <div>
            <p>Takk for meg!</p>
            <br />
            <p class="small">Stian Veum Møllersen / @mollerse</p>
            <p class="small">
              slides:
              <a
                href="https://mollerse.github.io/programming-minimalism-presentation/dist/hellostavanger2024/index.html"
                >github/mollerse/programming-minimalism-presentation</a
              >
            </p>
          </div>
        </section>
      </div>
    </div>
    <script type="module" src="src/slides.js" charset="utf-8"></script>
  </body>
</html>
